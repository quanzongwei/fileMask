## 一 用户密码生成多个md5数据
比如用户密码是123456
则生成以下md5数据
1. **md5-0**: 执行函数MD5("123456"), 用于用户登录验证,该数据保存在软件目录下authentication文件夹中
2. **md5-1**: 执行函数MD5("123456"+"1"), 每个被加密的文件末尾都会记录用户的**md5-1**的值.只有指定用户可以执行解密操作
3. **md5-23**:生成32为的字节数据,用于生成**内容加密秘钥**,生成代码如下:
```
public static byte[] getMd523ForContentEncrypt() {
    byte[] bytes32 = new byte[32];
    byte[] md5Bytes1 = MD5Utils.getMd5Bytes(getPassword() + 2);
    byte[] md5Bytes2 = MD5Utils.getMd5Bytes(getPassword() + 3);
    System.arraycopy(md5Bytes1, 0, bytes32, 0, 16);
    System.arraycopy(md5Bytes2, 0, bytes32, 16, 16);
    return bytes32;
}
```

4. **md5-45**:生成32字节数据,作为**uuid加密秘钥**,生成代码如下:
```
public static byte[] getMd545ForUuidEncrypt() {
    byte[] md5Bytes4 = new byte[32];
    byte[] md5Bytes1 = MD5Utils.getMd5Bytes(getPassword() + 4);
    byte[] md5Bytes2 = MD5Utils.getMd5Bytes(getPassword() + 5);
    System.arraycopy(md5Bytes1, 0, md5Bytes4, 0, 16);
    System.arraycopy(md5Bytes2, 0, md5Bytes4, 16, 16);
    return md5Bytes4;
}
```

## 二 文件尾部数据结构
加密文件成功后,会在文件尾部加上一段字节数据,数据结构如下所示:  
![image](https://github.com/quanzongwei/markdown-picture/blob/main/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png)  

**区域A**:16字节,存储**md5-1**数据,解密的时候,校验文件是否被当前用户加密,如果是,则允许解密  
**区域B**:16字节,存储标志位,前面三个字节为0x01的时候分别表示使用了文件名称加密,文件头部加密和文件内容加密,剩余的13字节为保留字段  
**区域C**:32字节,保存每次加密的时候生成的随机数经过**uuid加密秘钥**加密后的密文,该随机数,用于生成**内容加密秘钥**  
**区域D**:  4字节,文件头部加密的时候,保存了使用**内容加密秘钥**加密后的原始头部数据  
**区域E**:  N字节,保存了使用**内容加密秘钥**加密后的**原始文件名称**数据,文件名称长度不固定,所以可能N字节  
**区域F**:  8字节,长整型数据(Long),保存了原始文件长度,需要这个区域的原因是,区域E的长度不确定,导致尾部数据结构长度不确定,所以要记录原始文件长度  
**区域G**:16字节,保存字符串**"FileMaskTailFlag"**字符串的字节数据,用于标识该文件是使用FileMask软件加密过的文件  

## 三 两个重要秘钥
### 3.1 **uuid加密秘钥**
其中**uuid加密秘钥**即为: **md5-45**(如上文所示)
区域C存储的是uuid经过**uuid加密秘钥**加密后的密文, 原文数据不能直接暴露,这样做的主要目的是防止明文攻击

uuid密文生成过程如下所示:
```
uuid明文 xor md5-45 = uuid密文
```
### 3.2 **内容加密秘钥**
**内容加密秘钥**生成方式如下:
```
uuid明文 xor md5-23 = 内容加密秘钥
```

**内容加密秘钥**的使用场景
1. 文件名称加密,加密文件名称,如下所示:
```
文件名称明文 xor 内容加密秘钥 = 文件名称密文
```
2. 文件头部加密,加密文件头部四个字节的数据,如下所示:
```
文件头部明文 xor 内容加密秘钥 = 文件头部密文
```
3. 文件内容加密(全文加密),加密文件中每一个字节都被加密
```
文件全文明文 xor 内容加密秘钥 = 文件全文密文
```

## 四 加密解密流程
### 4.1 加密流程
1. 根据用户密码生成**md5-0**(16字节),**md5-1**(16字节),**md5-23**(32字节),**md5-45**(32字节)数据
2. 随机生成32字节的uuid字节数据
3. uuid原文 xor **md5-23**得到**内容加密秘钥**
4. **md5-1**的字节数据填入区域A
6. 得到uuid密文,填入区域C,计算方式(uuid明文 xor **md5-45**=uuid密文)
5. 设置加密标志字节
    1. 如果是文件名称加密,区域B的第一个字节设置为0x01
    2. 如果是文件头部加密,区域B的第二个字节设置为0x01
    3. 如果是文件内容加密,区域B的第三个字节设置为0x01
6. 执行加密
    1.  如果是文件头部加密,则将头部四个字节使用**内容加密秘钥**加密后填入区域D,计算方式(文件头部明文 xor **内容加密秘钥**=文件头部密文)
    2. 如果是文件名称加密,则将文件名称使用**内容加密秘钥**加密后填入区域E,计算方式(文件内容明文 xor **内容加密秘钥** = 文件密文); 接着文件名称重命名为当前文件夹下的唯一自增序号
    3. 如果是文件内容加密则将文件内容全部使用**内容加密秘钥**加密后,在原文所在位置.替换文件原始内容,计算方式(文件内容明文 xor **内容加密秘钥** = 文件密文)
7. 计算原始文件长度,填入区域F
8. 将**"FileMaskTailFlag"**字符串的字节数据写入区域G

到此为止, 加密操作完成, 请注意, 区域C使用**md5-45**加密后填入,区域D和区域E使用**内容加密秘钥**加密后填入,尾部数据结构中仅此三处区域是密文,其他区域无需加密

### 4.2 解密流程
1. 根据用户密码生成**md5-0**(16字节),**md5-1**(16字节),**md5-23**(32字节),**md5-45**(32字节)数据
2. 解析文件尾部,从区域G中读取16字节的字符串数据,如果为**"FileMaskTailFlag"**,则表示该文件被加密,否则无需解密
3. 解析区域F,获取原文长度,然后得到整个尾部数据结构
4. 获取区域A,和用户**md5-1**比较,如果相同,表示该文件是当前用户加密的,可以执行解密,否则解密不成功
5. 获取区域C中uuid的密文,使用**md5-45**进行解密得到uuid原文,计算方式(uuid密文 xor **md5-45** = uuid明文)
6. 根据uuid明文,得到**内容加密秘钥**,计算方式(uuid明文 xor **md5-23**=**内容加密秘钥**)
7. 获取加密标志字节
    1. 获取区域B中第一个字节数据,为0x01表示文件已使用文件名称加密
    2. 获取区域B中第二个字节数据,为0x01表示文件已使用文件头部加密
    3. 获取区域B中第三个字节数据,为0x01表示文件已使用文件内容加密
8. 执行解密
    1. 如果解密的是文件头部,则将区域D中的文件头部密文得到文件头部原文,计算方式(文件头部密文 xor **内容加密秘钥**=文件头部原文),然后将文件头部原始数据写入文件头部
    2. 如果解密的是文件名称, 则将区域E中的文件名称密文得到文件名称原文,计算方式(文件名称密文 xor **内容加密秘钥**=文件名称原文),然后对文件重命名
    3. 如果解密的是文件内容,则将文件的原始内容逐个字节使用**内容加密秘钥**解密,计算方式(文件内容密文 xor **内容加密秘钥**=文件内容原文)
9. 最后解密成功后,根据区域F中保存的原文长度信息, 将整个尾部数据结构全部删除,数据恢复到原始状态



## 五 答疑
### 5.1 为什么说该软件加密速度极快  
### 1. 文件名称加密
加密过程为:
```
文件名称原文 xor 内容加密秘钥 = 文件名称密文
```
只需要执行一次xor操作,和一次重命名操作即可,耗时是毫秒级  
#### 2. 文件头部加密
文件头部加密,作者使用了非常巧妙的方式,只加密头部四个字节
加密过程为:
```
文件头部原文 xor 内容加密秘钥 = 文件头部密文
```
这四个字节替换为FF FE 00 00,这四个字节头部表示UTF-32(little-endian编码),将文件标识为UTF-32编码,导致目前所有文本文件(BGK,UTF-8,ISO-8859-1)等等编码的文件,都会以UTF-32编码的方式被打开,于是显示乱码; 对于其他类型的文件(比如mp4,mp3,png,jpg),都会被误认为是UTF-32的文本文件,自然是无法打开的,所以文件头部加密,不保证绝对安全性,但是速度极快,只需要加密文件头部四个字节,应付日常生活中的普通的文件加密场景,已经是绰绰有余了

加密耗时是毫秒级,所以说速度极快  
#### 3. 文件内容加密
加密过程
```
文件内容原文 xor 内容加密秘钥 = 文件内容密文
```
相对于前两种加密方式,该方式较为耗时,因为他是对原文所有的字节数据执行加密,但是相对于当今世界上的对称加密算法(如:DES之类算法),他的加密速度是极快的,在保证绝对安全的前提下,只执行一次xor操作就能实现加密.而其他对称加密算法,一般都会经过很多轮的数据变换(映射, xor之类的),而我们只需要一轮,所以它快
### 5.2 为什么说该软件加密保证绝对的安全性(重点)
只要是使用**内容加密秘钥**加密过的数据,无法通过任何手段,任何工具进行破解,原理如下:
1. xor加密,在秘钥足够长的情况下,保证绝对的安全性(该软件使用32字节长度的秘钥)
2. xor唯一的缺点是无法防止已知明文攻击

该软件使用uuid和**md5-23**生成一个文件唯一的专属**内容加密秘钥**,由于每个文件生成的uuid会不同,所以,已知一个文件的明文和密文,得到的秘钥无法应用于其他的文件,因为其他文件的uuid是不一样的;
同时uuid数据使用**md5-45**进行加密, 导致uuid只有密文暴露出去,在只知道密文的情况下,无法推测出明文和秘钥,所以uuid明文无法被推测出,于是用户的**md5-23**绝对安全.所以被**内容加密秘钥**加密过的数据,具有绝对的安全性(这里包括:被加密的文件名称, 文件头部四个字节的数据,以及全文加密的所有内容)

简单理解就是,该软件使用加密的辅助数据uuid,防止了xor算法的已知明文攻击,最终保证了绝对的安全性

### 5.3 文件头部加密是不是不能保证绝对安全?
答案:是的

他只加密了前四个字节,只保证前四个字节的绝对安全,其他剩余内容都是明文,但是对于一般的用户,这种加密方式已经足够用了.

花絮: 作者有一段时间学习UTF编码,对UTF编码较为熟悉,然后写加密软件的时候突发奇想,仅仅通过替换前四个字节,把文件伪装成UTF-32编码的文件, 就达到很好的加密效果,所以作者为什么说这是一个富有思想的加密软件(它是有灵魂的哈哈)

### 5.4 为什么说用户体验良好?
作者站在用户的角度思考问题,其实作者本身就是最大的用户:比如级联加密,级联解密,帮助文档,操作日志等等功能可以极大的提高用户体验

### 5.5 为什么不加上修改密码的功能?
作者考虑到,密码修改后,使用原密码加密的文件是无法通过新密码解密的,于是为了避免加密后的文件无法解密,暂时不提供修改密码的功能.本质上就是希望用户第一次就把密码设置好

### 5.6 文件夹名称加密如何实现?
聪明的读者可能会有这个疑问, 文件夹和文件不同, 不像文件可以在尾部追加加密后的数据, 作者的处理方式如下:
* 在文件夹相同的目录下生成一个.fileMask的隐藏文件夹
* 该隐藏文件夹中生成一个和文件夹一样名字的文件
* 对文件夹的名称加密时, 会将加密后的数据,以及其他数据结构写入.fileMask文件夹下同名的文件

### 5.7 文件名称加密如何保证不重名?
每个文件夹下会生成一个.fileMask隐藏文件夹, 会生成一个.fmvalue文件, 该文件记录属于文件夹的自增Id, 每次对文件夹中的一个文件进行文件名称加密, 被加密的文件被命名为该自增Id, 同时自增Id的值加1,
以此来保证同个文件夹下各个被加密的文件名称不重复
